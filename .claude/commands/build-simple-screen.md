# Build Simple Screen Command
This is the High Certainty slash command because all tools/patterns are known, the implementation is standard CRUD + basic UI, and no research is needed. Use this for straightforward screens where you're confident about the entire implementation upfront.

---

## YOUR JOB:

### Gain Context
1. Read the 1overview.md from the prd's folder
2. Read your screen SRD (Screen Requirements Document)
3. Read the 2data.md prd in the prd's folder
4. Using the global components section in the screen SRD, look at the needed global components in the components/globalComponents folder

### Think Through Implementation
1. Identify what data entities, columns, and RLS policies are needed for this screen
2. Determine what parts of the screen should be components
3. Plan how global components fit into the screen layout
4. Structure the screen space and layout
5. Identify required states (active, loading, opened/closed, error)
6. Plan navigation in and out of the screen
7. Determine services needed for data operations

### Coding
1. Import and use global components
2. Build screen structure and logic
3. Implement data fetching and states
4. Handle navigation and user flows
5. Use very basic styling, but place things in the right space on the screen
6. Create services in the /services folder in the project root

### Create Supporting Code Files

**IMPORTANT: Write actual TypeScript/JavaScript code files, NOT documentation**

1. **SERVICES**: Create actual service .ts files in `/services/` folder
   - Each screen gets its own service file (e.g., `/services/settingsService.ts`)
   - Write real TypeScript functions for data operations, business logic, etc.

2. **DATA**: Add a detailed report of all data entities, RLS policies, descriptions, value type, enum, required?, default value into the 2data.md prd. Your data entry should be in this format:
```json
{
  "$schema": "public",
  "title": "table_name",
  "type": "object",
  "description": "Brief description of what this table represents",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique identifier auto-generated by system"
    },
    "name": {
      "type": "string",
      "minLength": 1,
      "maxLength": 255,
      "purpose": "display name",
      "owner": "product",
      "description": "User-friendly name shown in UI"
    },
    "status": {
      "type": "string",
      "enum": ["active","inactive"],
      "default": "active",
      "description": "Current state"
    }
  },
  "required": ["id","name"],
  "rls_policies": {
    "select": "auth.uid() IS NOT NULL",
    "insert": "auth.uid() IS NOT NULL",
    "update": "auth.uid() IS NOT NULL",
    "delete": "auth.uid() IS NOT NULL"
  }
}
```

3. **CREATE COMPLETION REPORT**: Create `/screenReports/[screenName]CompleteReport.md` with:
   - **What was built**: All files created, components used, services built, data added
   - **Why these decisions were made**: Explain component structure, data flow, navigation choices, state management approach
   - **Alternatives considered**: Document other approaches and why they weren't chosen

4. **UI/UX BIAS COMMENT**: Add the UI/UX bias section from the SRD as a comment at the bottom of the .tsx file

---

## Don't Worry About:
- Visual design (designers handle later)
- Color perfection
- Animations
- Advanced styling

---

## AVAILABLE TOOLS:

### React Native Reusables
- Use React Native Reusables components for consistent UI
- These are pre-built UI components that maintain app consistency
- Even though detailed styling isn't required, include these where appropriate
- Documentation: https://reactnativereusables.com/docs

### Supabase
- Standard Supabase queries for CRUD operations
- No special integrations or complex patterns needed for High Certainty screens
- Use the Supabase MCP to read documentation if needed (do NOT write to database via MCP)
