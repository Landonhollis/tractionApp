# DATA PRODUCT REQUIREMENT DOCUMENT

## Core Entities

### accounts
User account information and preferences.

**Fields:**
- id: uuid (primary key, default: gen_random_uuid())
- user_id: uuid (required, unique, FK -> auth.users.id)
- theme_name: text (nullable, stores user's selected theme)
- created_at: timestamptz (default: now())
- updated_at: timestamptz (default: now())

**RLS Policies:**
- Enable RLS on the accounts table
- SELECT: Users can only read their own account (user_id = auth.uid())
- UPDATE: Users can only update their own account (user_id = auth.uid())
- INSERT: Service role only (handled by database trigger)
- DELETE: Service role only

**Database Trigger:**
- Function: create_user_account_on_signup()
- Trigger: on_auth_user_created
- Event: AFTER INSERT on auth.users
- Action: Creates a record in accounts table with user_id set to new user's id and theme_name set to null

**Relationships:**
- accounts.user_id → auth.users.id (one-to-one) 

## Authentication & User Management

**Supabase Auth (READ-ONLY):**
- auth.users table is managed by Supabase and cannot be modified
- Contains: id (uuid), email, encrypted_password, created_at, etc.
- Used ONLY for authentication, not application data
- but the id from this table can be used on other tables. 

## SCREEN-GENERATED SCHEMAS
[Screen agents will append their data schemas below this line]

---

### AUTH SCREEN SCHEMA

**Generated by:** Auth Screen Implementation
**Date:** 2025-10-24

#### Authentication Flow Data Requirements

The authentication screen uses Supabase Auth's built-in `auth.users` table (read-only) and extends it with the `accounts` table for app-specific user data.

```json
{
  "$schema": "auth",
  "title": "users (read-only)",
  "type": "object",
  "description": "Supabase Auth managed table. Contains core authentication data.",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique user identifier, auto-generated by Supabase Auth"
    },
    "email": {
      "type": "string",
      "format": "email",
      "purpose": "authentication identifier",
      "owner": "user",
      "description": "User's email address for authentication",
      "validation": "Must be valid email format"
    },
    "encrypted_password": {
      "type": "string",
      "purpose": "authentication credential",
      "owner": "system",
      "description": "Bcrypt hashed password (never exposed to client)",
      "security": "Hashed using bcrypt, minimum 6 characters required"
    },
    "email_confirmed_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "email verification status",
      "owner": "system",
      "description": "Timestamp when email was verified, null if unverified"
    },
    "created_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Account creation timestamp"
    },
    "last_sign_in_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "activity tracking",
      "owner": "system",
      "description": "Last successful sign in timestamp"
    },
    "raw_user_meta_data": {
      "type": "object",
      "format": "jsonb",
      "purpose": "user-editable metadata",
      "owner": "user",
      "description": "Non-sensitive user metadata that user can update"
    },
    "raw_app_meta_data": {
      "type": "object",
      "format": "jsonb",
      "purpose": "app-managed metadata",
      "owner": "system",
      "description": "App metadata that user cannot update (e.g., roles, permissions)"
    }
  },
  "required": ["id", "email"],
  "rls_policies": {
    "note": "Managed by Supabase Auth, not directly accessible via RLS"
  },
  "relationships": {
    "accounts": "auth.users.id → accounts.user_id (one-to-one)",
    "identities": "auth.users.id → auth.identities.user_id (one-to-many)"
  }
}
```

```json
{
  "$schema": "public",
  "title": "accounts",
  "type": "object",
  "description": "App-specific user account data and preferences. Automatically created on user signup via database trigger.",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique account identifier",
      "default": "gen_random_uuid()"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to auth.users",
      "owner": "system",
      "description": "References auth.users.id, unique and required",
      "constraints": "UNIQUE, NOT NULL, ON DELETE CASCADE"
    },
    "theme_name": {
      "type": "string",
      "minLength": 1,
      "maxLength": 50,
      "purpose": "user preference",
      "owner": "user",
      "description": "User's selected theme (e.g., 'theme1', 'theme2')",
      "default": "null",
      "enum": ["theme1", "theme2", "theme3", "theme4", "theme5"]
    },
    "created_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Account record creation timestamp",
      "default": "now()"
    },
    "updated_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Last update timestamp, auto-updated on changes",
      "default": "now()"
    }
  },
  "required": ["id", "user_id", "created_at", "updated_at"],
  "rls_policies": {
    "select": "auth.uid() = user_id",
    "update": "auth.uid() = user_id",
    "insert": "Service role only (via trigger)",
    "delete": "Service role only"
  },
  "triggers": {
    "on_auth_user_created": {
      "event": "AFTER INSERT on auth.users",
      "function": "create_account_for_new_user()",
      "description": "Automatically creates account record when new user signs up"
    },
    "update_accounts_updated_at": {
      "event": "BEFORE UPDATE on accounts",
      "function": "update_updated_at_column()",
      "description": "Automatically updates updated_at timestamp on row changes"
    }
  },
  "relationships": {
    "users": "accounts.user_id → auth.users.id (one-to-one)"
  }
}
```

#### Authentication Service Methods

The auth screen uses the following service methods from `/services/authServices.ts`:

1. **signUpWithEmail(email, password)** - Creates new user account using Supabase Auth
2. **signInWithEmail(email, password)** - Authenticates existing user
3. **signInWithGoogle()** - Initiates Google OAuth flow (requires Google provider setup in Supabase dashboard)
4. **createUserAccount(userId)** - Creates account record (called automatically by trigger, but also used by AccountProvider)
5. **signOut()** - Signs out current user
6. **requestPasswordReset(email)** - Sends password reset email
7. **getSession()** - Retrieves current session
8. **getUser()** - Retrieves current user

#### Password Requirements

- Minimum length: 6 characters
- Stored as bcrypt hash in auth.users.encrypted_password
- Password validation occurs client-side and server-side (Supabase Auth)

#### Email Validation

- Format: Standard email regex `/^[^\s@]+@[^\s@]+\.[^\s@]+$/`
- Email confirmation can be enabled/disabled in Supabase dashboard
- Confirmation emails sent via Supabase's email service or custom SMTP

#### OAuth Providers

Currently configured for Google OAuth:
- Requires setup in Supabase dashboard (Auth > Providers > Google)
- Requires Google OAuth client ID and secret
- Redirect URLs must be configured in both Google Console and Supabase

#### Session Management

- Sessions managed automatically by Supabase Auth
- Stored in AsyncStorage (React Native)
- Auto-refresh enabled
- Session persistence enabled
- AccountProvider monitors auth state changes

#### Security Considerations

1. **Password Security:**
   - Passwords hashed using bcrypt
   - Never stored in plaintext
   - Minimum 6 character requirement

2. **RLS Policies:**
   - Users can only access their own account data
   - Account creation restricted to trigger (prevents manual creation)
   - No DELETE policy for users (prevents accidental account deletion)

3. **Email Verification:**
   - Optional email confirmation flow
   - Configurable in Supabase dashboard
   - Recommended for production

4. **OAuth Security:**
   - Uses PKCE flow for enhanced security
   - State parameter prevents CSRF attacks
   - Redirect URLs must be whitelisted

---

### VTO SCREEN SCHEMA

**Generated by:** VTO Screen Implementation
**Date:** 2025-10-30

```json
{
  "$schema": "public",
  "title": "vto",
  "type": "object",
  "description": "Stores the company's Vision/Traction Organizer strategic plan - a single-page strategic document with multiple sections",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique identifier for the VTO record",
      "default": "gen_random_uuid()"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to auth.users",
      "owner": "system",
      "description": "References auth.users.id, identifies VTO owner",
      "constraints": "NOT NULL, ON DELETE CASCADE"
    },
    "core_values": {
      "type": "string",
      "purpose": "vto section content",
      "owner": "user",
      "description": "Company core values section - fundamental beliefs and principles"
    },
    "core_focus": {
      "type": "string",
      "purpose": "vto section content",
      "owner": "user",
      "description": "Company core focus section - sweet spot, niche"
    },
    "ten_year_target": {
      "type": "string",
      "purpose": "vto section content",
      "owner": "user",
      "description": "10-year target section - long-term vision goal"
    },
    "marketing_strategy": {
      "type": "string",
      "purpose": "vto section content",
      "owner": "user",
      "description": "Marketing strategy section - how to reach target market"
    },
    "three_year_picture": {
      "type": "string",
      "purpose": "vto section content",
      "owner": "user",
      "description": "3-year picture section - mid-term vision"
    },
    "one_year_plan": {
      "type": "string",
      "purpose": "vto section content",
      "owner": "user",
      "description": "1-year plan section - annual goals and priorities"
    },
    "quarterly_rocks": {
      "type": "string",
      "purpose": "vto section content",
      "owner": "user",
      "description": "Quarterly rocks section - 90-day priorities"
    },
    "issues_list": {
      "type": "string",
      "purpose": "vto section content",
      "owner": "user",
      "description": "Issues list section - current challenges and obstacles"
    },
    "created_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "VTO record creation timestamp",
      "default": "now()"
    },
    "updated_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Last modification timestamp, auto-updated on changes",
      "default": "now()"
    }
  },
  "required": ["id", "user_id", "created_at", "updated_at"],
  "rls_policies": {
    "select": "auth.uid() = user_id",
    "insert": "auth.uid() = user_id",
    "update": "auth.uid() = user_id",
    "delete": "auth.uid() = user_id"
  },
  "triggers": {
    "update_vto_updated_at": {
      "event": "BEFORE UPDATE on vto",
      "function": "update_updated_at_column()",
      "description": "Automatically updates updated_at timestamp on row changes"
    }
  },
  "relationships": {
    "users": "vto.user_id → auth.users.id (many-to-one)"
  },
  "notes": [
    "Typically only one active VTO record per user",
    "Each column (except system fields) represents a VTO section",
    "Column names are formatted for display (e.g., core_values → 'Core Values')",
    "Section ordering is defined in application code, not database"
  ]
}
```

---

### SETTINGS SCREEN SCHEMA

**Generated by:** Settings Screen Implementation
**Date:** 2025-10-30

```json
{
  "$schema": "public",
  "title": "user_names",
  "type": "object",
  "description": "Stores user display names that can be edited in the settings screen",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique identifier for the user name record",
      "default": "gen_random_uuid()"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to auth.users",
      "owner": "system",
      "description": "References auth.users.id, unique identifier for the user",
      "constraints": "UNIQUE, NOT NULL, ON DELETE CASCADE"
    },
    "name": {
      "type": "string",
      "minLength": 1,
      "maxLength": 255,
      "purpose": "user display name",
      "owner": "user",
      "description": "User's display name shown throughout the app",
      "validation": "Cannot be empty, trimmed before save"
    },
    "created_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Record creation timestamp",
      "default": "now()"
    },
    "updated_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Last modification timestamp, auto-updated on changes",
      "default": "now()"
    }
  },
  "required": ["id", "user_id", "name", "created_at", "updated_at"],
  "rls_policies": {
    "select": "auth.uid() = user_id",
    "insert": "auth.uid() = user_id",
    "update": "auth.uid() = user_id",
    "delete": "auth.uid() = user_id"
  },
  "triggers": {
    "update_user_names_updated_at": {
      "event": "BEFORE UPDATE on user_names",
      "function": "update_updated_at_column()",
      "description": "Automatically updates updated_at timestamp on row changes"
    }
  },
  "relationships": {
    "users": "user_names.user_id → auth.users.id (one-to-one)"
  },
  "notes": [
    "Uses upsert operation with user_id conflict handling",
    "Name is trimmed before save to prevent whitespace-only names",
    "Typically one record per user, but technically allows multiple with unique constraint on user_id"
  ]
}
```

---

### SCORECARDS SCREEN SCHEMA

**Generated by:** Scorecards Screen Implementation
**Date:** 2025-10-30

```json
{
  "$schema": "public",
  "title": "metrics",
  "type": "object",
  "description": "Stores company metrics/measurables tracked across three organizational levels: company, departmental, and individual. Updated frequently (daily) for KPI tracking.",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique identifier for the metric",
      "default": "gen_random_uuid()"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to auth.users",
      "owner": "system",
      "description": "References auth.users.id, identifies metric creator/owner",
      "constraints": "NOT NULL, ON DELETE CASCADE"
    },
    "description": {
      "type": "string",
      "minLength": 1,
      "maxLength": 255,
      "purpose": "metric label",
      "owner": "user",
      "description": "User-friendly description of what is being measured",
      "validation": "Cannot be empty, required field"
    },
    "level": {
      "type": "string",
      "enum": ["company", "departmental", "individual"],
      "purpose": "organizational hierarchy",
      "owner": "user",
      "description": "Organizational level of the metric",
      "validation": "Must be one of: company, departmental, individual"
    },
    "department": {
      "type": "string",
      "minLength": 1,
      "maxLength": 100,
      "purpose": "departmental grouping",
      "owner": "user",
      "description": "Department name for departmental metrics, null otherwise",
      "validation": "Required when level = 'departmental', null otherwise"
    },
    "owner": {
      "type": "string",
      "minLength": 1,
      "maxLength": 255,
      "purpose": "individual metric owner name",
      "owner": "user",
      "description": "Owner name for individual metrics (from user_names table), null otherwise",
      "validation": "Required when level = 'individual', null otherwise"
    },
    "owner_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to user_names",
      "owner": "user",
      "description": "References user_names.id for individual metrics, null otherwise",
      "constraints": "ON DELETE SET NULL",
      "validation": "Required when level = 'individual', null otherwise"
    },
    "current_status": {
      "type": "number",
      "purpose": "current metric value",
      "owner": "user",
      "description": "Current numeric value of the metric, updated frequently (daily)",
      "validation": "Required numeric value, compared against min/max for status color"
    },
    "min": {
      "type": "number",
      "purpose": "acceptable range minimum",
      "owner": "user",
      "description": "Minimum acceptable value for green status indicator",
      "validation": "Required, used for status color calculation"
    },
    "max": {
      "type": "number",
      "purpose": "acceptable range maximum",
      "owner": "user",
      "description": "Maximum acceptable value for green status indicator",
      "validation": "Required, used for status color calculation"
    },
    "created_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Metric creation timestamp",
      "default": "now()"
    },
    "updated_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Last modification timestamp, auto-updated on changes",
      "default": "now()"
    }
  },
  "required": ["id", "user_id", "description", "level", "current_status", "min", "max", "created_at", "updated_at"],
  "rls_policies": {
    "select": "auth.uid() = user_id",
    "insert": "auth.uid() = user_id",
    "update": "auth.uid() = user_id",
    "delete": "auth.uid() = user_id"
  },
  "triggers": {
    "update_metrics_updated_at": {
      "event": "BEFORE UPDATE on metrics",
      "function": "update_updated_at_column()",
      "description": "Automatically updates updated_at timestamp on row changes"
    }
  },
  "relationships": {
    "users": "metrics.user_id → auth.users.id (many-to-one)",
    "user_names": "metrics.owner_id → user_names.id (many-to-one, nullable)"
  },
  "notes": [
    "Status color logic: green if min <= current_status <= max, red otherwise",
    "current_status updated frequently (daily) - edit flow optimized for this",
    "department field required when level = 'departmental'",
    "owner and owner_id required when level = 'individual'",
    "Visual hierarchy: company (2 layers), departmental (3 layers), individual (3 layers)"
  ]
}
```

---

### ROCKS SCREEN SCHEMA

**Generated by:** Rocks Screen Implementation
**Date:** 2025-10-31

```json
{
  "$schema": "public",
  "title": "rocks",
  "type": "object",
  "description": "Stores quarterly goals/priorities (rocks) across three organizational levels: company, departmental, and individual. Core component of Traction methodology for 90-day priorities.",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique identifier for the rock",
      "default": "gen_random_uuid()"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to auth.users",
      "owner": "system",
      "description": "References auth.users.id, identifies rock creator/owner",
      "constraints": "NOT NULL, ON DELETE CASCADE"
    },
    "title": {
      "type": "string",
      "minLength": 1,
      "maxLength": 500,
      "purpose": "rock name/description",
      "owner": "user",
      "description": "User-friendly title describing the quarterly goal",
      "validation": "Cannot be empty, required field"
    },
    "level": {
      "type": "string",
      "enum": ["company", "departmental", "individual"],
      "purpose": "organizational hierarchy",
      "owner": "user",
      "description": "Organizational level of the rock",
      "validation": "Must be one of: company, departmental, individual"
    },
    "department": {
      "type": "string",
      "minLength": 1,
      "maxLength": 100,
      "purpose": "departmental grouping",
      "owner": "user",
      "description": "Department name for departmental rocks, null otherwise",
      "validation": "Required when level = 'departmental', null otherwise"
    },
    "owner": {
      "type": "string",
      "minLength": 1,
      "maxLength": 255,
      "purpose": "individual rock owner name",
      "owner": "user",
      "description": "Owner name for individual rocks (from user_names table), null otherwise",
      "validation": "Required when level = 'individual', null otherwise"
    },
    "owner_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to user_names",
      "owner": "user",
      "description": "References user_names.id for individual rocks, null otherwise",
      "constraints": "ON DELETE SET NULL",
      "validation": "Required when level = 'individual', null otherwise"
    },
    "created_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Rock creation timestamp",
      "default": "now()"
    },
    "updated_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Last modification timestamp, auto-updated on changes",
      "default": "now()"
    }
  },
  "required": ["id", "user_id", "title", "level", "created_at", "updated_at"],
  "rls_policies": {
    "select": "auth.uid() = user_id",
    "insert": "auth.uid() = user_id",
    "update": "auth.uid() = user_id",
    "delete": "auth.uid() = user_id"
  },
  "triggers": {
    "update_rocks_updated_at": {
      "event": "BEFORE UPDATE on rocks",
      "function": "update_updated_at_column()",
      "description": "Automatically updates updated_at timestamp on row changes"
    }
  },
  "relationships": {
    "users": "rocks.user_id → auth.users.id (many-to-one)",
    "user_names": "rocks.owner_id → user_names.id (many-to-one, nullable)"
  },
  "notes": [
    "Rocks represent 90-day priorities in Traction methodology",
    "department field required when level = 'departmental'",
    "owner and owner_id required when level = 'individual'",
    "Visual hierarchy: company (2 layers), departmental (3 layers), individual (3 layers)",
    "Rocks displayed as squares in responsive grid layout",
    "No text truncation - all titles display fully"
  ]
}
```

---

### RIGHT PEOPLE RIGHT SEATS SCREEN SCHEMA

**Generated by:** Right People Right Seats Screen Implementation
**Date:** 2025-10-31

**No data entities required.**

This screen displays static, hardcoded educational content about the Right People Right Seats protocol from the Traction methodology. It is a reference/learning screen with no backend interactions, no data fetching, and no user-generated content.

**Content type:** Static hardcoded text organized into sections
**Backend requirements:** None
**Service functions:** None needed

---

### PROCESSES SCREEN SCHEMA

**Generated by:** Processes Screen Implementation
**Date:** 2025-10-31

```json
{
  "$schema": "public",
  "title": "processes",
  "type": "object",
  "description": "Stores documented company processes. Each process represents a core operational procedure that should be followed, supporting the Traction methodology's emphasis on documenting and standardizing core processes.",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique identifier for the process",
      "default": "gen_random_uuid()"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to auth.users",
      "owner": "system",
      "description": "References auth.users.id, identifies process creator/owner",
      "constraints": "NOT NULL, ON DELETE CASCADE"
    },
    "name": {
      "type": "string",
      "minLength": 1,
      "maxLength": 255,
      "purpose": "process title",
      "owner": "user",
      "description": "User-friendly name/title of the process",
      "validation": "Cannot be empty, required field"
    },
    "description": {
      "type": "string",
      "purpose": "process details",
      "owner": "user",
      "description": "Full description of the process including steps and details. Can be lengthy."
    },
    "created_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Process creation timestamp",
      "default": "now()"
    },
    "updated_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Last modification timestamp, auto-updated on changes",
      "default": "now()"
    }
  },
  "required": ["id", "user_id", "name", "created_at", "updated_at"],
  "rls_policies": {
    "select": "auth.uid() = user_id",
    "insert": "auth.uid() = user_id",
    "update": "auth.uid() = user_id",
    "delete": "auth.uid() = user_id"
  },
  "triggers": {
    "update_processes_updated_at": {
      "event": "BEFORE UPDATE on processes",
      "function": "update_updated_at_column()",
      "description": "Automatically updates updated_at timestamp on row changes"
    }
  },
  "relationships": {
    "users": "processes.user_id → auth.users.id (many-to-one)"
  },
  "notes": [
    "Processes are ordered by created_at DESC by default",
    "Description field is optional but name is required",
    "Long-press interaction allows edit/delete on individual processes",
    "Creating a new process immediately inserts it in DB, then opens editor"
  ]
}
```

---

### MEETING AGENDAS SCREEN SCHEMA

**Generated by:** Meeting Agendas Screen Implementation
**Date:** 2025-10-31

**No data entities required.**

This screen displays static, hardcoded educational content about various meeting agendas from the Traction methodology (Level 10, Quarterly Planning, Annual Planning, Same Page Meeting). It is a reference/learning screen with no backend interactions, no data fetching, and no user-generated content.

**Content type:** Static hardcoded text organized into meeting type sections
**Backend requirements:** None
**Service functions:** None needed

---

### LEADING OVER LAGGING SCREEN SCHEMA

**Generated by:** Leading Over Lagging Screen Implementation
**Date:** 2025-10-31

**No data entities required.**

This screen displays static, hardcoded educational content about the Leading Over Lagging Indicators protocol from the Traction methodology. It is a reference/learning screen with no backend interactions, no data fetching, and no user-generated content.

**Content type:** Static hardcoded text organized into sections (intro, lagging indicators, leading indicators, why leading matters, application)
**Backend requirements:** None
**Service functions:** None needed

---

### ISSUES SCREEN SCHEMA

**Generated by:** Issues Screen Implementation
**Date:** 2025-10-31

```json
{
  "$schema": "public",
  "title": "issues",
  "type": "object",
  "description": "Stores company issues across three organizational levels: quarterly, company, and departmental. Central to Traction methodology's issue identification and tracking process.",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique identifier for the issue",
      "default": "gen_random_uuid()"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to auth.users",
      "owner": "system",
      "description": "References auth.users.id, identifies issue creator/owner",
      "constraints": "NOT NULL, ON DELETE CASCADE"
    },
    "title": {
      "type": "string",
      "minLength": 1,
      "maxLength": 500,
      "purpose": "issue description",
      "owner": "user",
      "description": "User-friendly title describing the issue",
      "validation": "Cannot be empty, required field"
    },
    "level": {
      "type": "string",
      "enum": ["quarterly", "company", "departmental"],
      "purpose": "organizational hierarchy",
      "owner": "user",
      "description": "Organizational level of the issue",
      "validation": "Must be one of: quarterly, company, departmental"
    },
    "department": {
      "type": "string",
      "minLength": 1,
      "maxLength": 100,
      "purpose": "departmental grouping",
      "owner": "user",
      "description": "Department name for departmental issues, null otherwise",
      "validation": "Required when level = 'departmental', null otherwise"
    },
    "status": {
      "type": "string",
      "enum": ["open", "in_progress", "resolved"],
      "default": "open",
      "purpose": "issue tracking status",
      "owner": "user",
      "description": "Current status of the issue"
    },
    "priority": {
      "type": "number",
      "purpose": "sorting order",
      "owner": "user",
      "description": "Priority/order of the issue within its level, higher number = higher priority",
      "default": "0"
    },
    "created_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Issue creation timestamp",
      "default": "now()"
    },
    "updated_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Last modification timestamp, auto-updated on changes",
      "default": "now()"
    }
  },
  "required": ["id", "user_id", "title", "level", "created_at", "updated_at"],
  "rls_policies": {
    "select": "auth.uid() = user_id",
    "insert": "auth.uid() = user_id",
    "update": "auth.uid() = user_id",
    "delete": "auth.uid() = user_id"
  },
  "triggers": {
    "update_issues_updated_at": {
      "event": "BEFORE UPDATE on issues",
      "function": "update_updated_at_column()",
      "description": "Automatically updates updated_at timestamp on row changes"
    }
  },
  "relationships": {
    "users": "issues.user_id → auth.users.id (many-to-one)"
  },
  "notes": [
    "Issues represent organizational challenges at different levels",
    "department field required when level = 'departmental'",
    "Default sorting by created_at DESC within each level",
    "Departmental issues grouped by department name",
    "Visual hierarchy: thin separators between issues, thicker separators between departments",
    "Long-press interaction (500ms threshold) for edit",
    "Different delete UX patterns: Quarterly/Company use Delete button, Departmental uses Delete in popup"
  ]
}
```

---

### IDS SCREEN SCHEMA

**Generated by:** IDS Screen Implementation
**Date:** 2025-10-31

**No data entities required.**

This screen displays static, hardcoded educational content about the IDS (Identify, Discuss, Solve) protocol from the Traction methodology. It is a reference/learning screen with no backend interactions, no data fetching, and no user-generated content.

**Content type:** Static hardcoded text organized into sections (Identify, Discuss, Solve, Application)
**Backend requirements:** None
**Service functions:** None needed

---

### GWC SCREEN SCHEMA

**Generated by:** GWC Screen Implementation
**Date:** 2025-10-31

**No data entities required.**

This screen displays static, hardcoded educational content about the GWC (Get it, Want it, Capacity to do it) protocol from the Traction methodology. It is a reference/learning screen with no backend interactions, no data fetching, and no user-generated content.

**Content type:** Static hardcoded text organized into sections (Introduction, Get It, Want It, Capacity to Do It, All Three Required, Application)
**Backend requirements:** None
**Service functions:** None needed

---

### DASHBOARD SCREEN SCHEMA

**Generated by:** Dashboard Screen Implementation
**Date:** 2025-10-31

**No new data entities required.**

This screen aggregates and displays existing data from multiple tables. It provides a read-only overview of company health metrics across personal, departmental, and company levels.

**Data sources used:**
- `rocks` table (filtered by level='individual' and owner_id for personal rocks)
- `issues` table (filtered by level='departmental' and level='company')
- `metrics` table (filtered by owner_id for personal, level='departmental' for departmental, level='company' for company)
- `processes` table (filtered by user_id for individual processes)

**Service functions:**
All service functions are in `/services/dashboardService.ts`:
- `getPersonalRocks(userId)` - Fetches individual-level rocks for current user
- `getDepartmentIssues()` - Fetches departmental-level issues
- `getCompanyIssues()` - Fetches company-level issues
- `getPersonalMeasurables(userId)` - Fetches metrics owned by current user
- `getDepartmentalMeasurables()` - Fetches departmental-level metrics
- `getCompanyMeasurables()` - Fetches company-level metrics
- `getIndividualProcesses(userId)` - Fetches processes owned by current user
- `isMetricInRange(metric)` - Helper to determine green/red status color
- `getAllDashboardData(userId)` - Fetches all dashboard data in parallel

**Display logic:**
- Metrics display with green background if `min <= current_status <= max`, red otherwise
- All text fields truncated to 10 lines maximum
- Responsive grid layout: single column on mobile (<768px), multi-column on tablet/desktop
- Cards use floating aesthetic with shadow/elevation
- Empty states show placeholder text when no data exists

**No database changes required** - All necessary tables and columns already exist from previous screen implementations.

---

### DATA HISTORY SCREEN SCHEMA

**Generated by:** Data History Screen Implementation
**Date:** 2025-10-31

```json
{
  "$schema": "public",
  "title": "data_history",
  "type": "object",
  "description": "Stores historical snapshots of metric values for trend visualization. Each record represents a single data point capturing a metric's current_status, min, and max values at a specific timestamp.",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique identifier for the data history record",
      "default": "gen_random_uuid()"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to auth.users",
      "owner": "system",
      "description": "References auth.users.id, identifies history record owner",
      "constraints": "NOT NULL, ON DELETE CASCADE"
    },
    "metric_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to metrics",
      "owner": "system",
      "description": "References metrics.id, links history to specific metric",
      "constraints": "NOT NULL, ON DELETE CASCADE"
    },
    "current_status": {
      "type": "number",
      "purpose": "historical metric value",
      "owner": "system",
      "description": "The metric value at the time of capture"
    },
    "min": {
      "type": "number",
      "purpose": "historical minimum threshold",
      "owner": "system",
      "description": "The minimum acceptable value at the time of capture"
    },
    "max": {
      "type": "number",
      "purpose": "historical maximum threshold",
      "owner": "system",
      "description": "The maximum acceptable value at the time of capture"
    },
    "timestamp": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "temporal reference",
      "owner": "system",
      "description": "When this data point was captured",
      "default": "now()"
    },
    "created_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Record creation timestamp",
      "default": "now()"
    }
  },
  "required": ["id", "user_id", "metric_id", "current_status", "min", "max", "timestamp", "created_at"],
  "rls_policies": {
    "select": "auth.uid() = user_id",
    "insert": "auth.uid() = user_id",
    "update": "Service role only",
    "delete": "auth.uid() = user_id"
  },
  "indexes": [
    {
      "name": "idx_data_history_metric_timestamp",
      "columns": ["metric_id", "timestamp DESC"],
      "description": "Optimizes queries filtering by metric and sorting by time"
    },
    {
      "name": "idx_data_history_user_timestamp",
      "columns": ["user_id", "timestamp DESC"],
      "description": "Optimizes queries filtering by user and time ranges"
    }
  ],
  "relationships": {
    "users": "data_history.user_id → auth.users.id (many-to-one)",
    "metrics": "data_history.metric_id → metrics.id (many-to-one)"
  },
  "notes": [
    "Historical snapshots are created when metrics are updated in scorecard screen",
    "timestamp field used for time-series visualization and date range filtering",
    "min and max values stored to show changing thresholds over time",
    "Data points colored green when min <= current_status <= max, red otherwise",
    "Indexes optimize performance for time-range queries (1-month, 6-month, all-time)"
  ]
}
```

---

### ACCOUNTABILITY CHART SCREEN SCHEMA

**Generated by:** Accountability Chart Screen Implementation
**Date:** 2025-10-31

```json
{
  "$schema": "public",
  "title": "accountability_nodes",
  "type": "object",
  "description": "Stores organizational positions/roles on the accountability chart. Each node represents a position with title, names, and canvas coordinates.",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique identifier for the node",
      "default": "gen_random_uuid()"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to auth.users",
      "owner": "system",
      "description": "References auth.users.id, identifies node owner",
      "constraints": "NOT NULL, ON DELETE CASCADE"
    },
    "title": {
      "type": "string",
      "minLength": 1,
      "maxLength": 255,
      "purpose": "position title",
      "owner": "user",
      "description": "Job title or role name"
    },
    "names": {
      "type": "string",
      "maxLength": 500,
      "purpose": "person names",
      "owner": "user",
      "description": "Name(s) of person(s) in this role"
    },
    "description": {
      "type": "string",
      "purpose": "role details",
      "owner": "user",
      "description": "Detailed description of responsibilities and accountabilities"
    },
    "x_position": {
      "type": "number",
      "purpose": "canvas coordinate",
      "owner": "user",
      "description": "X coordinate on the canvas (in pixels)",
      "default": "0"
    },
    "y_position": {
      "type": "number",
      "purpose": "canvas coordinate",
      "owner": "user",
      "description": "Y coordinate on the canvas (in pixels)",
      "default": "0"
    },
    "created_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Node creation timestamp",
      "default": "now()"
    },
    "updated_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Last modification timestamp",
      "default": "now()"
    }
  },
  "required": ["id", "user_id", "x_position", "y_position", "created_at", "updated_at"],
  "rls_policies": {
    "select": "auth.uid() = user_id",
    "insert": "auth.uid() = user_id",
    "update": "auth.uid() = user_id",
    "delete": "auth.uid() = user_id"
  },
  "triggers": {
    "update_accountability_nodes_updated_at": {
      "event": "BEFORE UPDATE on accountability_nodes",
      "function": "update_updated_at_column()",
      "description": "Automatically updates updated_at timestamp on row changes"
    }
  },
  "relationships": {
    "users": "accountability_nodes.user_id → auth.users.id (many-to-one)"
  },
  "notes": [
    "Positions draggable on canvas with real-time coordinate updates",
    "Canvas uses SVG coordinate system",
    "Long-press shows description popup with edit option"
  ]
}
```

```json
{
  "$schema": "public",
  "title": "accountability_lines",
  "type": "object",
  "description": "Stores connection lines between organizational positions on the accountability chart. Each line represents a reporting relationship or accountability connection.",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "purpose": "primary key",
      "owner": "system",
      "description": "Unique identifier for the line",
      "default": "gen_random_uuid()"
    },
    "user_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to auth.users",
      "owner": "system",
      "description": "References auth.users.id, identifies line owner",
      "constraints": "NOT NULL, ON DELETE CASCADE"
    },
    "start_x": {
      "type": "number",
      "purpose": "line start coordinate",
      "owner": "user",
      "description": "X coordinate of line start point",
      "default": "0"
    },
    "start_y": {
      "type": "number",
      "purpose": "line start coordinate",
      "owner": "user",
      "description": "Y coordinate of line start point",
      "default": "0"
    },
    "end_x": {
      "type": "number",
      "purpose": "line end coordinate",
      "owner": "user",
      "description": "X coordinate of line end point",
      "default": "0"
    },
    "end_y": {
      "type": "number",
      "purpose": "line end coordinate",
      "owner": "user",
      "description": "Y coordinate of line end point",
      "default": "0"
    },
    "start_node_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to accountability_nodes",
      "owner": "user",
      "description": "References accountability_nodes.id for start node",
      "constraints": "ON DELETE CASCADE"
    },
    "end_node_id": {
      "type": "string",
      "format": "uuid",
      "purpose": "foreign key to accountability_nodes",
      "owner": "user",
      "description": "References accountability_nodes.id for end node",
      "constraints": "ON DELETE CASCADE"
    },
    "created_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Line creation timestamp",
      "default": "now()"
    },
    "updated_at": {
      "type": "string",
      "format": "timestamptz",
      "purpose": "audit trail",
      "owner": "system",
      "description": "Last modification timestamp",
      "default": "now()"
    }
  },
  "required": ["id", "user_id", "start_x", "start_y", "end_x", "end_y", "created_at", "updated_at"],
  "rls_policies": {
    "select": "auth.uid() = user_id",
    "insert": "auth.uid() = user_id",
    "update": "auth.uid() = user_id",
    "delete": "auth.uid() = user_id"
  },
  "triggers": {
    "update_accountability_lines_updated_at": {
      "event": "BEFORE UPDATE on accountability_lines",
      "function": "update_updated_at_column()",
      "description": "Automatically updates updated_at timestamp on row changes"
    }
  },
  "relationships": {
    "users": "accountability_lines.user_id → auth.users.id (many-to-one)",
    "start_node": "accountability_lines.start_node_id → accountability_nodes.id (many-to-one, nullable)",
    "end_node": "accountability_lines.end_node_id → accountability_nodes.id (many-to-one, nullable)"
  },
  "notes": [
    "Lines can be dragged by their endpoints to reposition",
    "start_node_id and end_node_id are nullable to allow free-form lines",
    "Lines auto-update when connected nodes are moved",
    "Line endpoints can snap to nearby nodes"
  ]
}
```

---